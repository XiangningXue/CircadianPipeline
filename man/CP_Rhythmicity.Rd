% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CP_Rhythmicity.R
\name{CP_Rhythmicity}
\alias{CP_Rhythmicity}
\title{Title The Rhythmicity Analysis with Cosinor}
\usage{
CP_Rhythmicity(
  x1,
  x2 = NULL,
  method = "Sidak_FS",
  period = 24,
  alpha = 0.05,
  alpha.FDR = 0.05,
  CI = FALSE,
  p.adjust.method = "BH",
  parallel.ncores = 1
)
}
\arguments{
\item{x1}{group I data. A list with the following components: \itemize{
\item data: data.frame genes in rows and samples in columns.
\item time: time of expression. Should be in the same order as samples in the data.
\item gname: labels for gene. Should be in the same order as rows in the data.
}}

\item{x2}{group II data. Same as x1 for formats.}

\item{method}{character string specifying the algorithm used for joint rhythmicity categorization. Should be one of "Sidak_FS", "Sidak_BS", "VDA", "AWFisher".}

\item{period}{integer. The length of the oscillation cycle. Default is 24 for circadian signals.}

\item{alpha}{integer. Threshold for rhythmicity p-value in joint rhythmicity categorization. If CI = TRUE, (1-alpha) confidence interval for parameters will be returned.}

\item{alpha.FDR}{integer. Threshold for rhythmicity p-value in joint rhythmicity categorization adjusted for global FDR control.}

\item{CI}{logical. Should confidence interval for A, phase and M be returned?}

\item{p.adjust.method}{input for p.adjust() in R package \code{stat}.}

\item{parallel.ncores}{integer. Number of cores used if using parallel computing with \code{mclapply()}. Not functional for windows system.}
}
\value{
A list of origical x input and rhythmicity analysis estimates. If given two data sets, joint rhythmicity categorization will also be available in component rhythm.joint
}
\description{
This function either takes one data set and performs only rhythmicity analysis with cosinor, or takes two data sets and categorize the genes into joint rhythmicity categories.
}
\examples{
x = CP_sim_data(ngene=1000, nsample=30, A1=c(1, 3), A2=c(1, 3),
phase1=c(0, pi/4), phase2=c(pi/4, pi/2),
M1=c(4, 6), M2=c(4, 6), sigma1=1, sigma2=1)

rhythm.res = CP_Rhythmicity(x1 = x[[1]], x2 = x[[2]])
}
